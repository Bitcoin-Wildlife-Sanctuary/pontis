{
    "comment": "This is a mock offchain db. Because we can only save the state hash on l1 chain, so we need to save the origin state offchain. ",
    "comment2": "we use the txid as the primary key for depositInfo and bridgeState. it's easy to implement a real offchain db like redis, sqlite, etc.",
    "depositInfo": {
        "txid1  ": {
            "recipient": "recipient1",
            "amount": "amount1"
        },
        "txid2": {
            "recipient": "recipient2",
            "amount": "amount2"
        },
        "txid3": {
            "recipient": "recipient3",
            "amount": "amount3"
        }
    },
    "comment3": "here we record the latest bridge txid, so we can get the bridge state from the latest bridge txid. This avoid potential multiple bridge utxos, which cause us hard to choose the correct bridge utxo.",
    "latestBridgeTxid": "txid",
    "bridgeState": {
        "txid1": {
            "batchesRoot": "batchesRoot",
            "merkleTree": ["batch1", "batch2", "batch3"],
            "depositAggregatorSPK": "depositAggregatorSPK"
        },
        "txid2": {
            "batchesRoot": "batchesRoot",
            "merkleTree": ["batch1", "batch2", "batch3"],
            "depositAggregatorSPK": "depositAggregatorSPK"
        }
    }
}
